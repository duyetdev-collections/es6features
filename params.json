{"name":"Es6features","tagline":"Overview of ECMAScript 6 features","body":"# ECMAScript 6 <sup>[git.io/es6features](http://git.io/es6features)</sup>\r\n\r\n## Introduction\r\nECMAScript 6, also known as ECMAScript 2015, is the latest version of the ECMAScript standard.  ES6 is a significant update to the language, and the first update to the language since ES5 was standardized in 2009. Implementation of these features in major JavaScript engines is [underway now](http://kangax.github.io/es5-compat-table/es6/).\r\n\r\nSee the [ES6 standard](http://www.ecma-international.org/ecma-262/6.0/) for full specification of the ECMAScript 6 language.\r\n\r\nES6 includes the following new features:\r\n- [arrows](#arrows)\r\n- [classes](#classes)\r\n- [enhanced object literals](#enhanced-object-literals)\r\n- [template strings](#template-strings)\r\n- [destructuring](#destructuring)\r\n- [default + rest + spread](#default--rest--spread)\r\n- [let + const](#let--const)\r\n- [iterators + for..of](#iterators--forof)\r\n- [generators](#generators)\r\n- [unicode](#unicode)\r\n- [modules](#modules)\r\n- [module loaders](#module-loaders)\r\n- [map + set + weakmap + weakset](#map--set--weakmap--weakset)\r\n- [proxies](#proxies)\r\n- [symbols](#symbols)\r\n- [subclassable built-ins](#subclassable-built-ins)\r\n- [promises](#promises)\r\n- [math + number + string + array + object APIs](#math--number--string--array--object-apis)\r\n- [binary and octal literals](#binary-and-octal-literals)\r\n- [reflect api](#reflect-api)\r\n- [tail calls](#tail-calls)\r\n\r\n## ECMAScript 6 Features\r\n\r\n### Arrows\r\nArrows are a function shorthand using the `=>` syntax.  They are syntactically similar to the related feature in C#, Java 8 and CoffeeScript.  They support both statement block bodies as well as expression bodies which return the value of the expression.  Unlike functions, arrows share the same lexical `this` as their surrounding code.\r\n\r\n```JavaScript\r\n// Expression bodies\r\nvar odds = evens.map(v => v + 1);\r\nvar nums = evens.map((v, i) => v + i);\r\nvar pairs = evens.map(v => ({even: v, odd: v + 1}));\r\n\r\n// Statement bodies\r\nnums.forEach(v => {\r\n  if (v % 5 === 0)\r\n    fives.push(v);\r\n});\r\n\r\n// Lexical this\r\nvar bob = {\r\n  _name: \"Bob\",\r\n  _friends: [],\r\n  printFriends() {\r\n    this._friends.forEach(f =>\r\n      console.log(this._name + \" knows \" + f));\r\n  }\r\n}\r\n```\r\n\r\n### Classes\r\nES6 classes are a simple sugar over the prototype-based OO pattern.  Having a single convenient declarative form makes class patterns easier to use, and encourages interoperability.  Classes support prototype-based inheritance, super calls, instance and static methods and constructors.\r\n\r\n```JavaScript\r\nclass SkinnedMesh extends THREE.Mesh {\r\n  constructor(geometry, materials) {\r\n    super(geometry, materials);\r\n\r\n    this.idMatrix = SkinnedMesh.defaultMatrix();\r\n    this.bones = [];\r\n    this.boneMatrices = [];\r\n    //...\r\n  }\r\n  update(camera) {\r\n    //...\r\n    super.update();\r\n  }\r\n  get boneCount() {\r\n    return this.bones.length;\r\n  }\r\n  set matrixType(matrixType) {\r\n    this.idMatrix = SkinnedMesh[matrixType]();\r\n  }\r\n  static defaultMatrix() {\r\n    return new THREE.Matrix4();\r\n  }\r\n}\r\n```\r\n\r\n### Enhanced Object Literals\r\nObject literals are extended to support setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making super calls, and computing property names with expressions.  Together, these also bring object literals and class declarations closer together, and let object-based design benefit from some of the same conveniences.\r\n\r\n```JavaScript\r\nvar obj = {\r\n    // __proto__\r\n    __proto__: theProtoObj,\r\n    // Shorthand for ‘handler: handler’\r\n    handler,\r\n    // Methods\r\n    toString() {\r\n     // Super calls\r\n     return \"d \" + super.toString();\r\n    },\r\n    // Computed (dynamic) property names\r\n    [ 'prop_' + (() => 42)() ]: 42\r\n};\r\n```\r\n\r\n### Template Strings\r\nTemplate strings provide syntactic sugar for constructing strings.  This is similar to string interpolation features in Perl, Python and more.  Optionally, a tag can be added to allow the string construction to be customized, avoiding injection attacks or constructing higher level data structures from string contents.\r\n\r\n```JavaScript\r\n// Basic literal string creation\r\n`In JavaScript '\\n' is a line-feed.`\r\n\r\n// Multiline strings\r\n`In JavaScript this is\r\n not legal.`\r\n\r\n// String interpolation\r\nvar name = \"Bob\", time = \"today\";\r\n`Hello ${name}, how are you ${time}?`\r\n\r\n// Construct an HTTP request prefix is used to interpret the replacements and construction\r\nPOST`http://foo.org/bar?a=${a}&b=${b}\r\n     Content-Type: application/json\r\n     X-Credentials: ${credentials}\r\n     { \"foo\": ${foo},\r\n       \"bar\": ${bar}}`(myOnReadyStateChangeHandler);\r\n```\r\n\r\n### Destructuring\r\nDestructuring allows binding using pattern matching, with support for matching arrays and objects.  Destructuring is fail-soft, similar to standard object lookup `foo[\"bar\"]`, producing `undefined` values when not found.\r\n\r\n```JavaScript\r\n// list matching\r\nvar [a, , b] = [1,2,3];\r\n\r\n// object matching\r\nvar { op: a, lhs: { op: b }, rhs: c }\r\n       = getASTNode()\r\n\r\n// object matching shorthand\r\n// binds `op`, `lhs` and `rhs` in scope\r\nvar {op, lhs, rhs} = getASTNode()\r\n\r\n// Can be used in parameter position\r\nfunction g({name: x}) {\r\n  console.log(x);\r\n}\r\ng({name: 5})\r\n\r\n// Fail-soft destructuring\r\nvar [a] = [];\r\na === undefined;\r\n\r\n// Fail-soft destructuring with defaults\r\nvar [a = 1] = [];\r\na === 1;\r\n```\r\n\r\n### Default + Rest + Spread\r\nCallee-evaluated default parameter values.  Turn an array into consecutive arguments in a function call.  Bind trailing parameters to an array.  Rest replaces the need for `arguments` and addresses common cases more directly.\r\n\r\n```JavaScript\r\nfunction f(x, y=12) {\r\n  // y is 12 if not passed (or passed as undefined)\r\n  return x + y;\r\n}\r\nf(3) == 15\r\n```\r\n```JavaScript\r\nfunction f(x, ...y) {\r\n  // y is an Array\r\n  return x * y.length;\r\n}\r\nf(3, \"hello\", true) == 6\r\n```\r\n```JavaScript\r\nfunction f(x, y, z) {\r\n  return x + y + z;\r\n}\r\n// Pass each elem of array as argument\r\nf(...[1,2,3]) == 6\r\n```\r\n\r\n### Let + Const\r\nBlock-scoped binding constructs.  `let` is the new `var`.  `const` is single-assignment.  Static restrictions prevent use before assignment.\r\n\r\n\r\n```JavaScript\r\nfunction f() {\r\n  {\r\n    let x;\r\n    {\r\n      // okay, block scoped name\r\n      const x = \"sneaky\";\r\n      // error, const\r\n      x = \"foo\";\r\n    }\r\n    // error, already declared in block\r\n    let x = \"inner\";\r\n  }\r\n}\r\n```\r\n\r\n### Iterators + For..Of\r\nIterator objects enable custom iteration like CLR IEnumerable or Java Iterable.  Generalize `for..in` to custom iterator-based iteration with `for..of`.  Don’t require realizing an array, enabling lazy design patterns like LINQ.\r\n\r\n```JavaScript\r\nlet fibonacci = {\r\n  [Symbol.iterator]() {\r\n    let pre = 0, cur = 1;\r\n    return {\r\n      next() {\r\n        [pre, cur] = [cur, pre + cur];\r\n        return { done: false, value: cur }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfor (var n of fibonacci) {\r\n  // truncate the sequence at 1000\r\n  if (n > 1000)\r\n    break;\r\n  console.log(n);\r\n}\r\n```\r\n\r\nIteration is based on these duck-typed interfaces (using [TypeScript](http://typescriptlang.org) type syntax for exposition only):\r\n```TypeScript\r\ninterface IteratorResult {\r\n  done: boolean;\r\n  value: any;\r\n}\r\ninterface Iterator {\r\n  next(): IteratorResult;\r\n}\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n```\r\n\r\n### Generators\r\nGenerators simplify iterator-authoring using `function*` and `yield`.  A function declared as function* returns a Generator instance.  Generators are subtypes of iterators which include additional  `next` and `throw`.  These enable values to flow back into the generator, so `yield` is an expression form which returns a value (or throws).\r\n\r\nNote: Can also be used to enable ‘await’-like async programming, see also ES7 `await` proposal.\r\n\r\n```JavaScript\r\nvar fibonacci = {\r\n  [Symbol.iterator]: function*() {\r\n    var pre = 0, cur = 1;\r\n    for (;;) {\r\n      var temp = pre;\r\n      pre = cur;\r\n      cur += temp;\r\n      yield cur;\r\n    }\r\n  }\r\n}\r\n\r\nfor (var n of fibonacci) {\r\n  // truncate the sequence at 1000\r\n  if (n > 1000)\r\n    break;\r\n  console.log(n);\r\n}\r\n```\r\n\r\nThe generator interface is (using [TypeScript](http://typescriptlang.org) type syntax for exposition only):\r\n\r\n```TypeScript\r\ninterface Generator extends Iterator {\r\n    next(value?: any): IteratorResult;\r\n    throw(exception: any);\r\n}\r\n```\r\n\r\n### Unicode\r\nNon-breaking additions to support full Unicode, including new Unicode literal form in strings and new RegExp `u` mode to handle code points, as well as new APIs to process strings at the 21bit code points level.  These additions support building global apps in JavaScript.\r\n\r\n```JavaScript\r\n// same as ES5.1\r\n\"𠮷\".length == 2\r\n\r\n// new RegExp behaviour, opt-in ‘u’\r\n\"𠮷\".match(/./u)[0].length == 2\r\n\r\n// new form\r\n\"\\u{20BB7}\"==\"𠮷\"==\"\\uD842\\uDFB7\"\r\n\r\n// new String ops\r\n\"𠮷\".codePointAt(0) == 0x20BB7\r\n\r\n// for-of iterates code points\r\nfor(var c of \"𠮷\") {\r\n  console.log(c);\r\n}\r\n```\r\n\r\n### Modules\r\nLanguage-level support for modules for component definition.  Codifies patterns from popular JavaScript module loaders (AMD, CommonJS). Runtime behaviour defined by a host-defined default loader.  Implicitly async model – no code executes until requested modules are available and processed.\r\n\r\n```JavaScript\r\n// lib/math.js\r\nexport function sum(x, y) {\r\n  return x + y;\r\n}\r\nexport var pi = 3.141593;\r\n```\r\n```JavaScript\r\n// app.js\r\nimport * as math from \"lib/math\";\r\nalert(\"2π = \" + math.sum(math.pi, math.pi));\r\n```\r\n```JavaScript\r\n// otherApp.js\r\nimport {sum, pi} from \"lib/math\";\r\nalert(\"2π = \" + sum(pi, pi));\r\n```\r\n\r\nSome additional features include `export default` and `export *`:\r\n\r\n```JavaScript\r\n// lib/mathplusplus.js\r\nexport * from \"lib/math\";\r\nexport var e = 2.71828182846;\r\nexport default function(x) {\r\n    return Math.log(x);\r\n}\r\n```\r\n```JavaScript\r\n// app.js\r\nimport ln, {pi, e} from \"lib/mathplusplus\";\r\nalert(\"2π = \" + ln(e)*pi*2);\r\n```\r\n\r\n### Module Loaders\r\nModule loaders support:\r\n- Dynamic loading\r\n- State isolation\r\n- Global namespace isolation\r\n- Compilation hooks\r\n- Nested virtualization\r\n\r\nThe default module loader can be configured, and new loaders can be constructed to evaluate and load code in isolated or constrained contexts.\r\n\r\n```JavaScript\r\n// Dynamic loading – ‘System’ is default loader\r\nSystem.import('lib/math').then(function(m) {\r\n  alert(\"2π = \" + m.sum(m.pi, m.pi));\r\n});\r\n\r\n// Create execution sandboxes – new Loaders\r\nvar loader = new Loader({\r\n  global: fixup(window) // replace ‘console.log’\r\n});\r\nloader.eval(\"console.log('hello world!');\");\r\n\r\n// Directly manipulate module cache\r\nSystem.get('jquery');\r\nSystem.set('jquery', Module({$: $})); // WARNING: not yet finalized\r\n```\r\n\r\n### Map + Set + WeakMap + WeakSet\r\nEfficient data structures for common algorithms.  WeakMaps provides leak-free object-key’d side tables.\r\n\r\n```JavaScript\r\n// Sets\r\nvar s = new Set();\r\ns.add(\"hello\").add(\"goodbye\").add(\"hello\");\r\ns.size === 2;\r\ns.has(\"hello\") === true;\r\n\r\n// Maps\r\nvar m = new Map();\r\nm.set(\"hello\", 42);\r\nm.set(s, 34);\r\nm.get(s) == 34;\r\n\r\n// Weak Maps\r\nvar wm = new WeakMap();\r\nwm.set(s, { extra: 42 });\r\nwm.size === undefined\r\n\r\n// Weak Sets\r\nvar ws = new WeakSet();\r\nws.add({ data: 42 });\r\n// Because the added object has no other references, it will not be held in the set\r\n```\r\n\r\n### Proxies\r\nProxies enable creation of objects with the full range of behaviors available to host objects.  Can be used for interception, object virtualization, logging/profiling, etc.\r\n\r\n```JavaScript\r\n// Proxying a normal object\r\nvar target = {};\r\nvar handler = {\r\n  get: function (receiver, name) {\r\n    return `Hello, ${name}!`;\r\n  }\r\n};\r\n\r\nvar p = new Proxy(target, handler);\r\np.world === 'Hello, world!';\r\n```\r\n\r\n```JavaScript\r\n// Proxying a function object\r\nvar target = function () { return 'I am the target'; };\r\nvar handler = {\r\n  apply: function (receiver, ...args) {\r\n    return 'I am the proxy';\r\n  }\r\n};\r\n\r\nvar p = new Proxy(target, handler);\r\np() === 'I am the proxy';\r\n```\r\n\r\nThere are traps available for all of the runtime-level meta-operations:\r\n\r\n```JavaScript\r\nvar handler =\r\n{\r\n  get:...,\r\n  set:...,\r\n  has:...,\r\n  deleteProperty:...,\r\n  apply:...,\r\n  construct:...,\r\n  getOwnPropertyDescriptor:...,\r\n  defineProperty:...,\r\n  getPrototypeOf:...,\r\n  setPrototypeOf:...,\r\n  enumerate:...,\r\n  ownKeys:...,\r\n  preventExtensions:...,\r\n  isExtensible:...\r\n}\r\n```\r\n\r\n### Symbols\r\nSymbols enable access control for object state.  Symbols allow properties to be keyed by either `string` (as in ES5) or `symbol`.  Symbols are a new primitive type. Optional `description` parameter used in debugging - but is not part of identity.  Symbols are unique (like gensym), but not private since they are exposed via reflection features like `Object.getOwnPropertySymbols`.\r\n\r\n\r\n```JavaScript\r\nvar MyClass = (function() {\r\n\r\n  // module scoped symbol\r\n  var key = Symbol(\"key\");\r\n\r\n  function MyClass(privateData) {\r\n    this[key] = privateData;\r\n  }\r\n\r\n  MyClass.prototype = {\r\n    doStuff: function() {\r\n      ... this[key] ...\r\n    }\r\n  };\r\n\r\n  return MyClass;\r\n})();\r\n\r\nvar c = new MyClass(\"hello\")\r\nc[\"key\"] === undefined\r\n```\r\n\r\n### Subclassable Built-ins\r\nIn ES6, built-ins like `Array`, `Date` and DOM `Element`s can be subclassed.\r\n\r\nObject construction for a function named `Ctor` now uses two-phases (both virtually dispatched):\r\n- Call `Ctor[@@create]` to allocate the object, installing any special behavior\r\n- Invoke constructor on new instance to initialize\r\n\r\nThe known `@@create` symbol is available via `Symbol.create`.  Built-ins now expose their `@@create` explicitly.\r\n\r\n```JavaScript\r\n// Pseudo-code of Array\r\nclass Array {\r\n    constructor(...args) { /* ... */ }\r\n    static [Symbol.create]() {\r\n        // Install special [[DefineOwnProperty]]\r\n        // to magically update 'length'\r\n    }\r\n}\r\n\r\n// User code of Array subclass\r\nclass MyArray extends Array {\r\n    constructor(...args) { super(...args); }\r\n}\r\n\r\n// Two-phase 'new':\r\n// 1) Call @@create to allocate object\r\n// 2) Invoke constructor on new instance\r\nvar arr = new MyArray();\r\narr[1] = 12;\r\narr.length == 2\r\n```\r\n\r\n### Math + Number + String + Array + Object APIs\r\nMany new library additions, including core Math libraries, Array conversion helpers, String helpers, and Object.assign for copying.\r\n\r\n```JavaScript\r\nNumber.EPSILON\r\nNumber.isInteger(Infinity) // false\r\nNumber.isNaN(\"NaN\") // false\r\n\r\nMath.acosh(3) // 1.762747174039086\r\nMath.hypot(3, 4) // 5\r\nMath.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2\r\n\r\n\"abcde\".includes(\"cd\") // true\r\n\"abc\".repeat(3) // \"abcabcabc\"\r\n\r\nArray.from(document.querySelectorAll('*')) // Returns a real Array\r\nArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior\r\n[0, 0, 0].fill(7, 1) // [0,7,7]\r\n[1, 2, 3].find(x => x == 3) // 3\r\n[1, 2, 3].findIndex(x => x == 2) // 1\r\n[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2]\r\n[\"a\", \"b\", \"c\"].entries() // iterator [0, \"a\"], [1,\"b\"], [2,\"c\"]\r\n[\"a\", \"b\", \"c\"].keys() // iterator 0, 1, 2\r\n[\"a\", \"b\", \"c\"].values() // iterator \"a\", \"b\", \"c\"\r\n\r\nObject.assign(Point, { origin: new Point(0,0) })\r\n```\r\n\r\n### Binary and Octal Literals\r\nTwo new numeric literal forms are added for binary (`b`) and octal (`o`).\r\n\r\n```JavaScript\r\n0b111110111 === 503 // true\r\n0o767 === 503 // true\r\n```\r\n\r\n### Promises\r\nPromises are a library for asynchronous programming.  Promises are a first class representation of a value that may be made available in the future.  Promises are used in many existing JavaScript libraries.\r\n\r\n```JavaScript\r\nfunction timeout(duration = 0) {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(resolve, duration);\r\n    })\r\n}\r\n\r\nvar p = timeout(1000).then(() => {\r\n    return timeout(2000);\r\n}).then(() => {\r\n    throw new Error(\"hmm\");\r\n}).catch(err => {\r\n    return Promise.all([timeout(100), timeout(200)]);\r\n})\r\n```\r\n\r\n### Reflect API\r\nFull reflection API exposing the runtime-level meta-operations on objects.  This is effectively the inverse of the Proxy API, and allows making calls corresponding to the same meta-operations as the proxy traps.  Especially useful for implementing proxies.\r\n\r\n```JavaScript\r\n// No sample yet\r\n```\r\n\r\n### Tail Calls\r\nCalls in tail-position are guaranteed to not grow the stack unboundedly.  Makes recursive algorithms safe in the face of unbounded inputs.\r\n\r\n```JavaScript\r\nfunction factorial(n, acc = 1) {\r\n    'use strict';\r\n    if (n <= 1) return acc;\r\n    return factorial(n - 1, n * acc);\r\n}\r\n\r\n// Stack overflow in most implementations today,\r\n// but safe on arbitrary inputs in ES6\r\nfactorial(100000)\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}